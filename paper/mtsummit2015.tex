\documentclass[]{article}
\usepackage[letterpaper]{geometry}
\usepackage{mtsummit2015}
\usepackage{times}
\usepackage{hyperref}
\usepackage{latexsym}
\usepackage{natbib}
\usepackage{layout}
\usepackage{multirow}
\usepackage[dvipsnames]{xcolor}  % Coloured text etc.
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\usepackage{listings}
\usepackage{color}
\usepackage{caption}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[nolist,nohyperlinks]{acronym}
\usepackage{textcomp}
\usetikzlibrary{shapes,arrows}

\newcommand{\confname}{AMTA 2018}
\newcommand{\website}{\protect\url{https://sites.google.com/view/loresmt/}}
\newcommand{\contactname}{research track co-chair Yaser Al-Onaizan}
\newcommand{\contactemail}{chaohong.liu@adaptcentre.ie}
\newcommand{\conffilename}{mtsummit2015}
\newcommand{\downloadsite}{\protect\url{http://www.conference.amtaweb.org/}}
\newcommand{\paperlength}{$8$ (eight)}
\newcommand{\shortpaperlength}{$4$ (four)}

%% do not add any other page- or text-size instruction here

\parskip=0.00in

\begin{document}

\begin{acronym}
\acro{NMT}{Neural Machine Translation}
\acro{MT}{Machine Translation}
\acro{UNMT}{Unsupervised Machine Translation Using Monolingual Corpora Only}
\acro{LSTM}{Long Short Term Memory}
\end{acronym}

% \mtsummitHeader{x}{x}{xxx-xxx}{2015}{45-character paper description goes here}{Author(s) initials and last name go here}
\title{\bf System description of Supervised and Unsupervised  \acl{NMT} approaches from {"NL~Processing"} team at DeepHack.Babel task}
\author{\name{\bf Ilya Gusev} \hfill  \addr{ilya.gusev@phystech.edu}\\
        \addr{MIPT, Dolgoprudny, Moscow Region, 141701, Russian Federation}
\AND
        \name{\bf Artem Oboturov} \hfill \addr{oboturov@gmail.com}
}

\maketitle
\pagestyle{empty}

\begin{abstract}
  A comparison~\footnote{Images used to train models are publicly available at \url{https://github.com/aoboturov/loresmt-nlprocessing}} of supervised and unsupervised \ac{NMT} models was done for the corpora provided by the DeepHack.Babel competition.
  It is shown that for even small parallel corpus, fully supervised \ac{NMT} gives better results than fully unsupervised for the case of constrained domain of the corpus.
  We have also implemented a fully unsupervised and a semi-supervised \ac{NMT} models which have not given positive results compared to fully supervised models.
  An oblivious setup is described where participants know at no point what language pair is used for translation, so no extra-corpora data could be integrated in pre-submission phase or during training.
  Finally, future competition organizers should find ways to protect their competition set ups against various strategies (we have reported two) to discover language pairs in the oblivious setup.
\end{abstract}

\section{Competition Setup}
\label{sect:setup}

The work presented here is motivated by the following observation: an industrial \ac{NMT} system is usually built on a huge parallel corpora and trained days or even weeks.
A "raw" \ac{NMT} model is then tuned by additional training on client-specific data and by augmentation with some domain-specific information.
What if it is not as important to have such a heavy and difficult to train model and instead use a simple bootstart model based only on the clients data with a subsequent augmentation done with unsupervised learning which would use any available non-parallel corpora.

We present results obtained by the "NL~Processing" team in the DeepHack.Babel hackathon~\footnote{The leaderboard: \url{http://contest.deephack.me/c/babel/leaderboard}} on semi-supervised machine translation.
Organizers of the competition created an oblivious setup - a case in which the source and target languages are not known at any point of competition and the machine translation system can be trained with no specific tuning to the language pair.
Langauge pairs were trained and scored independently, so no one sought to build a universal model.
The scoring system would run training and then run translation with the trained model.
Participants have no insight into the process and could only observe the final score for a submission and/or the failure status.
For each language pair participants could have submitted multiple entries and based on the score adapt their models.
Submissions were scored in BLEU-4~\citep{papineni2002bleu}.
The fact that the language pair was not known, should have prevented participants from any specific tuning and pre-training of submitted models: whatever model was submitted, it had a strict time limit for training and inference (8 hours in total for both stages) and a computational budget constrained by a single dedicated GPU, no access from the evaluation server to the internet was allowed.

For each language pair the following datasets~\footnote{Contest overview: \url{http://contest.deephack.me/c/babel/overview}} were available:
\begin{itemize}
  \item each language of a pair has one monolingual corpora, {\tt 1M} sentences;
  \item a small parallel corpus, {\tt 50K} sentence pairs;
  \item and an input corpus to be translated from source to target language, {\tt 6K} sentences.
\end{itemize}
There were 3 language pairs used during the competition: {\tt En-Ru} for test, {\tt Lv-En} for qualification and {\tt En-Ko} for final scoring.
Data for training and test are not available publicly and organizers would not release them.
Therefore we could only provide a summary~\footnote{Samples from the parallel corpora are provided online \url{https://github.com/aoboturov/loresmt-nlprocessing\#the-corpora-extracts}}: Table~\ref{table:corpora_stats} describes statistics for the corpora.

\begin{table}[h!]
\begin{center}
\begin{tabular}{ l c c c c }
Pair & Source Tokens & Source Words & Target Tokens & Target Words \\
\hline
En-Ru & 14M & 165519 & 19M & 345444 \\
Lv-En & 21M & 502858 & 24M & 341012 \\
En-Ko & 14M & 157649 & 7M & 530124 \\
\end{tabular}
\end{center}
\caption{Descriptive statistics for the corpora.}
\label{table:corpora_stats}
\end{table}

The machine translation system could be built as a fully supervised one, though the parallel corpus is small ({\tt 50K}); as an unsupervised one, using the two monolingual corpora; and as a semi-supervised one.
Given the problem at hand, a simple fully supervised \ac{NMT} baseline was implemented which was then compared against the \ac{UNMT} model which was trained both in fully unsupervised and semi-supervised modes.

Preparing for the {{DeepHack.Babel}} hackaton we have looked into recent supervised \ac{NMT} systems~\footnote{One could find them on-line: \url{https://github.com/aoboturov/aoboturov-deephack-babel-qualification}} including: Google's seq2seq~\citep{Britz:2017}, {FAIR Sequence-to-Sequence Toolkit}~\citep{gehring2017convs2s}, {{Marian-NMT}}~\citep{junczys2016neural} and Sockeye~\citep{Sockeye:17}.
For the competition itself it was decided by the team against doing only supervised models.
The hackaton theme was unsupervised and semi-supervised approaches in the oblivious setup, so that became our primary focus.

Section~\ref{sect:baseline} will outline the baseline which was used to benchmark the \ac{UNMT} in the oblivious setup.
In Section~\ref{sect:unmt} we discuss the experiments with the \ac{UNMT} model for the oblivious setup.
Finally, in Section~\ref{sect:nonoblivious} we investigate whether prior knowledge of a language pair gives an advantage for the unsupervised \ac{NMT} approach.

\section{Baseline}
\label{sect:baseline}

A supervised \ac{NMT} model~\footnote{For a full description of the Encoder-Decoder architecture see \url{https://github.com/aoboturov/loresmt-nlprocessing\#supervised-model-description}.} was chosen for the baseline.
The model was implemented in OpenNMT~\citep{opennmt} and had the following Encoder-Decoder architecture:
\begin{itemize}
\item encoder is a continuous embedding from the source language to a $300$ dimensional space;
\item followed by a $3$-layers \acs{LSTM} with a dropout;
\item the decoder has a stacked \acs{LSTM} with a dropout, a global attention \citep{luong2015effective} and a continuous embedding from a $300$ dimensional space.
\end{itemize}

For each language pair a model was trained only on a {\tt 50K} parallel corpus with a {\tt 5\%} validation set.
Training on a NVIDIA Titan XP GPU usually lasted $20$ to $30$ minutes.
The results are provided in Table~\ref{table:results}.
Additionally, embeddings were trained with Fasttext~\citep{bojanowski2016enriching}.
We have tried a number of different combinations of \acs{LSTM} depths and cell-sizes, but optimal hyper parameters for the supervised baseline were not searched for: we have realized that, even without optimal hyperparameters, the baseline beats the \ac{UNMT} score by an order of magnitude.

\begin{table}
\begin{center}
\begin{tabular}{ l c c c }
Model & En-Ru Score & Lv-En Score & En-Ko Score \\
\hline
Supervized, 10 Epochs & 0.28915 & 0.05756 & 0.25418 \\
In to Out Copy & 0.02123 & 0.02075 & 0.02759 \\
Unsupervised UNMT & - & 0.00428 & - \\
Semi-supervised UNMT & - & - & 0.03632 \\
Competitors Best & - & 0.23338 & 0.30074 \\
Literature Best, conscious & 0.29800 & 0.22900 & 0.27950
\end{tabular}
\end{center}
\caption{Evaluation results for models in the oblivious setup, measured in BLEU scores.}
\caption*{\small
First four model are the ones which we have produced for the competition, followed by a result reported by a winning team from each round.
The last model is reported from literature reviews for the conscious setup.
The best {\tt Lv-En} and  {\tt En-Ru} are reported on newstest2017 corpora in \cite{bojar2017findings}.
% Lv-En \url{http://matrix.statmt.org/matrix/output/1872?score_id=22981}
%\url{http://matrix.statmt.org/matrix/output/1875?score_id=21229}
{\tt En-Ko} is reported after \cite{junczys2016coppa} which uses COPPA corpus.
{\tt Literature Best} here provides an indicative upper boundary on what an \acf{MT} system trained on a generic parallel corpus might score on a translation task when the language pair is known.
}
\label{table:results}
\end{table}

On the {\tt Lv-En} langauge pair model performance was mediocre.
It could be explained by the fact that {\tt En-Ru} and {\tt En-Ko} were topic-resticted corpora - both were related to tourism only, while the {\tt Lv-En} corpora was extracted from a news feed which had no topic constraints.

\section{Unsupervised Neural Machine Translation}
\label{sect:unmt}

Competition included not only parallel corpus for each language pair, but also {\tt 1M} monolingual corpus for each language.
One way to leverage this data is to use unsupervised \ac{NMT} model described in \cite{DBLP:journals/corr/abs-1711-00043}.
The code for this model is not available, so we built our own implementation~\footnote{Implementation of the \acs{UNMT}: \url{https://github.com/IlyaGusev/UNMT}} based on PyTorch~\citep{paszke2017automatic} framework. 
Our system can be used in several ways.
First, one can use it like an ordinary supervised \ac{NMT} system.
Second, it can work as a denoising autoencoder.
Finally, one can train this model on monolingual corpora using a predefined initial model which we call the zero model.
The goal of the competition was to find unsupervised and semi-supervised \ac{MT} methods applicable in practice.
The supervised case was already covered in Section~\ref{sect:baseline}.
A fully unsupervised case is covered in Section~\ref{sect:fully_unsupervised}, while a semi-supervised approach is described in Section~\ref{sect:semi_unsupervised}.

The \ac{UNMT}~\footnote{The \ac{UNMT} model used for translation is described in \url{https://github.com/aoboturov/loresmt-nlprocessing\#unmt-model-description}} would train iteratively using adversarial training~\citep{goodfellow2016nips} with a discriminator~\footnote{The Discriminator description is available online \url{https://github.com/aoboturov/loresmt-nlprocessing\#unmt-discriminator-description}}.
In both semi-supervised and unsupervised cases we run an unsupervised training epoch which starts from a batch of sentences translated by a model from a previous iteration of unsupervised training (or zero model if it is the first iteration) followed by a noising layer and a pass through the model which is trained on the current iteration.
Figure~\ref{fig:unsupervised_training} gives a graphical explanation of the training process.

\begin{figure}
\begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
\draw;

\end{tikzpicture}
\caption{Unsupervised epoch training for the \ac{UNMT} model.}
\label{fig:unsupervised_training}
\todo[inline]{ao}{Diagram from Figure 2 bottom of the UNMT paper}
\end{figure}

There are two types of zero models which we have used: dictionary translation and a supervised model trained on a small corpora.
The translation model has an RNN Encoder-Decoder architecture \citep{DBLP:journals/corr/ChoMGBSB14} with continuous embeddings and a global attention \citep{luong2015effective}.

\subsection{\ac{UNMT} with a dictionary translation zero model}
\label{sect:fully_unsupervised}
The dictionary translation model is a translation process which uses a dictionary obtained with an unsupervised embedding~\citep{conneau2017word} (or otherwise an external dictionary could have been used if the language pair was known) to translate each sentence word by word.

To debug the zero model we first check the input to output copy which is reported in Table~\ref{table:results} as the {\tt In to Out Copy} result.
Normally, we would expect an improvement over the {\tt In to Out Copy}, because it is closely related to dictionary translation: words which are not in the dictionary would be copied over from source to target sentences.

\todo{ao}{Run word-by-word separately to see the impact}

We do not know whether there is an error in our system or the corpora are too small.
BLEU scores on all language pairs were below {\tt 0.01 BLEU}.

\subsection{\ac{UNMT} with a supervised model trained on a small corpora}
\label{sect:semi_unsupervised}
\todo{ao}{update this section with the results I have obtained myself running the simulations}

\section{Prior Language Pair Information}
\label{sect:nonoblivious}

We describe how the oblivious setup could be hacked to get and understanding of 
Competition was structured in a way to prevent participants from knowing what language pairs were being tested.
The Hackathon could have had any pair-combination of $42$ languages supported by {{Booking.com}}, so the total number of models (if trained undirectionally) would have been over $1500$.
Given that even for our simplest baseline model, an individual \ac{NMT} model is at least $300$~Megabytes, we would have had to train individual unidirectional models (likely multiple days) on some external parallel data (which we did not have for all language pairs) and package around half a Terabyte of data inside a docker container (which is technologically unrealistic).
We could have followed Google's \ac{NMT} approach~\citep{johnson2016google} or any other \ac{MT} approach, which have an intermediate neural representation, to reduce the total number of models to just one, but it still should have been trained on external parallel corpora (even if they all would be just English to any other of the $41$ languages).
To reduce the combinatorial complexity of the problem, one could somehow identify the language pair and then just train a single unidirectional model.
Competition testing system prevented access to any external resources and remote calls during training and inference phases.
The sheer size of models representations, the total training time, amount and diversity of training data and technical constraints would make pre-training a non-viable option.

The only information available to participants was the BLEU score and the failure or success status for the submission.
One could devise at least two attacks to identify the language pair and then using this prior knowledge, use it to consturct a better translation algorithm.

In Table~\ref{table:results} we also report the best BLEU scores available within the conference submissions for each of the pairs trained on common corpora.
We could see that a margin of improvement is just a couple of BLEU points for {\tt En-Ru} and {\tt En-Ko} pairs.
On the other hand, {\tt Lv-En} has a very poor result and we would expect that both unsupervised learning and prior knowledge would improve this score.

We will explore the nature of Side-Channel attacks against the language pair.
We describe two ways how a language pair identification attack could be executed.
The execution time attack is supposed to identify the language pair in a single submission, while the second one would require multiple submissions.
The number of submissions used to identify the language pair would matter when the total number of submissions for the competition is limited.

\subsection{Using Execution Time}
\label{sect:execution_time_attack}

There is a way to identify the language pair in one submission by using the side-channel attack technique.
In this particular case, the side-channel would be the execution time of the translation algorithm whereby a language identification routine is run on each of the non-parallel corpora and both languages of the pair are detected.
Given that the routine could identify $N$ languages, all the pairs could be enumerated to define a mapping to natural numbers in range $1\dots N*(N-1)$.
Provided that a specific constant delay is used, one could divide the total execution time by the delay duration to obtain the index of the pair in the mapping.

\subsection{Using Failure Status}
\label{sect:failure_status_attack}

The second way is a slower combinatorial way where a failure status is used as an indicator of the language belonging to a subset of languages being tested.
A set of all languages identifiable by the routine could be searched in log-time in a breadth search fashion descending only into subsets where we have established an inclusion relationship.

\section{Conclusion}

A generic fully unsupervised machine translation problem is hard.
In some cases, one could obtain good machine translation models by having a small data set for a limited domain, e.g. for a case of travelling destinations or some other domain-specific translation.
Although semi-supervised translation might improve the results, we have not observed that a fully supervised model used as the zero model for the \ac{UNMT} made any translation improvement over a regular supervised model.
Poor performance of the \ac{UNMT} has to be investigated further, possibly by providing larger non-parallel corpora and changing \ac{UNMT} model architecture.

\small

\bibliographystyle{apalike}
\bibliography{mtsummit2015}

\end{document}

